PostgreSQL → Estado oficial do porto

    - chegadas
    - operadores
    - alertas oficiais
    - cargas
    - cais

MongoDB → Eventos e deteções

    - logs da IA
    - inferências YOLO
    - eventos do Decision Engine
    - telemetria
    - auditoria

Redis → Estado volátil (CRÍTICO para decisões)

    - anti-duplicação
    - cache de matrículas
    - estados temporários
    - rate limiting
    - sincronização entre microserviços
    - flags de “já processei isto”

Kafka → backbone de comunicação

    - detections
    - decisions
    - alerts
    - updates
    - telemetria
    - operações do porto


Para testar:

Resumo de testes (Data Module) — uso com Decision Engine mock
=============================================================

Objetivo
--------
Testar o fluxo principal do `data-module` em ambiente local usando o Decision Engine em modo mock (stub incluído em `de_stub.py`).

Pré-requisitos
--------------
- Docker e Docker Compose instalados na máquina.
- Estar na pasta do serviço: `IntelligentLogistics/src/Data_Module`.
- Ports 8000, 8001, 5432, 27017, 6379 livres ou ajustados no compose.

Arquivos importantes
-------------------
- `docker-compose.yml` (já presente) — define postgres, mongo, redis e data-module.
- `docker-compose.override.yml` — adiciona o serviço `decision-engine` (stub).
- `de_stub.py` — stub do Decision Engine (rodará em http://decision-engine:8001).
- `services/decision_service.py` — chama o DE e persiste detections/events.
- `models/pydantic_models.py` — modelos Pydantic (resposta/validação).
- `tests/test_connection.sh` — script de teste rápido (opcional).

Iniciar a stack
---------------
1) Ir para a pasta do módulo:
   cd IntelligentLogistics/src/Data_Module

3) Construir e subir:
   docker compose up -d --build (depois remover service do decision engine mock)

Verificar que os containers estão UP/Healthy:
   docker compose ps
   docker ps

Health do Data Module
---------------------
Verifica o endpoint health do data-module:
   curl -s http://localhost:8000/health | jq .

Deve retornar algo como:
{
  "status": "ok",
  "components": { "postgres": true, "mongo": true, "redis": true },
  "decision_engine_url": "http://decision-engine:8001"
}

Testar pipeline — enviar uma deteção
-----------------------------------
Exemplo de curl que o stub reconhece como match (matrícula "AA-00-11"):

   curl -v -X POST http://localhost:8000/api/v1/detections \
     -H "Content-Type: application/json" \
     -d '{"timestamp":"2025-11-30T12:00:00Z","gate_id":1,"matricula_detectada":"AA-00-11","confidence":0.95}'

O que esperar:
- Resposta HTTP 200 com o documento da deteção (campo `decision` incluído).
- Inserção na colecção `intelligent_logistics.detections` (Mongo).
- Inserção na colecção `intelligent_logistics.events` (Mongo).
- Publicação numa channel Redis (ex.: `notifications:driver:driver-123`).
- Se existir um registo em `chegadas_diarias` com id correspondente (por exemplo id 1),
  o `data-module` tentará actualizar a linha em Postgres conforme a decisão do DE.

Inspecionar MongoDB
-------------------
Contar documentos:
   docker exec -it dm_mongo mongosh --eval 'db.getSiblingDB("intelligent_logistics").detections.count()'
   docker exec -it dm_mongo mongosh --eval 'db.getSiblingDB("intelligent_logistics").events.count()'

Ver último documento:
   docker exec -it dm_mongo mongosh --eval 'db.getSiblingDB("intelligent_logistics").detections.find().sort({_id:-1}).limit(1).pretty()'

Ouvir notificações Redis
------------------------
No terminal subscreve o canal esperado:
   docker exec -it dm_redis redis-cli
   > SUBSCRIBE notifications:driver:driver-123
OU usa pattern:
   > PSUBSCRIBE notifications:*

Ver logs do serviço
-------------------
- data-module:
   docker logs --tail 200 -f dm_data_module

- decision-engine (stub):
   docker logs --tail 200 -f dm_decision_engine

- mongo / postgres / redis:
   docker logs --tail 200 -f dm_mongo
   docker logs --tail 200 -f dm_postgres
   docker logs --tail 200 -f dm_redis

Criar chegada de teste em Postgres (opcional)
--------------------------------------------
rodar tests/test_connection.sh
Verifica depois:
   docker exec -it dm_postgres psql -U porto -d porto_logistica -c "SELECT id_chegada, matricula_pesado, estado_entrega FROM chegadas_diarias WHERE id_chegada = 1;"

Smoke test (sequência)
----------------------
1. curl health
2. POST /api/v1/detections (exemplo acima)
3. contar documents em Mongo
4. subscrever Redis para ver a mensagem
5. verificar logs do dm_data_module

Dicas de troubleshooting
------------------------
- Se `data-module` ficar em `health: starting`, confirma que `dm_decision_engine` está `healthy` e listening em 8001.
- Se vires ImportError -> procura módulos vazios em `services/` e implementa stubs mínimos.
- Se houver validação Pydantic (timestamp/gate_id/confidence), confirma que o documento retornado inclui esses campos.
- Para reconstruir por completo:
   docker compose down -v
   docker compose up -d --build

Notas sobre o Decision Engine mock
---------------------------------
- O stub está em `de_stub.py` e responde em `/process-detection`.
- Por enquanto o stub devolve:
  - matricula == "AA-00-11" -> granted + matched_chegada_id: 1 + notify_channel "notifications:driver:driver-123"
  - confidence < 0.5 -> pending
  - default -> denied
- Mantém o URL do DE como `http://decision-engine:8001` nas variáveis de ambiente do `data-module` dentro do compose.

