/**
 * IntelligentLogistics - Jenkins Control Panel
 * 
 * Interface centralizada para gerir todos os serviÃ§os nas diferentes VMs.
 * 
 * AÃ§Ãµes disponÃ­veis:
 * - deploy: Build e deploy do serviÃ§o
 * - status: Ver estado dos containers
 * - logs: Ver logs do container
 * - restart: Reiniciar container
 * - stop: Parar container
 * 
 * Jenkins Credentials:
 * - ssh-vm-key: SSH key para acesso Ã s VMs
 * - minio-credentials: MinIO username/password
 */

pipeline {
    agent any
    
    parameters {
        // ================================================================
        // AÃ‡ÃƒO A EXECUTAR
        // ================================================================
        choice(
            name: 'ACTION',
            choices: ['status', 'deploy', 'restart', 'stop', 'logs'],
            description: '''
                status  â†’ Ver estado dos containers selecionados
                deploy  â†’ Build e deploy dos serviÃ§os selecionados
                restart â†’ Reiniciar containers selecionados
                stop    â†’ Parar containers selecionados
                logs    â†’ Ver logs dos containers selecionados
            '''
        )
        
        // ================================================================
        // SELEÃ‡ÃƒO DE SERVIÃ‡OS (checkboxes)
        // ================================================================
        booleanParam(name: 'ALL_SERVICES', defaultValue: false, description: 'âš¡ Selecionar TODOS os serviÃ§os')
        
        booleanParam(name: 'AGENT_A', defaultValue: false, description: 'ğŸšš Agent A - Truck Detection (10.255.32.134)')
        booleanParam(name: 'AGENT_B', defaultValue: false, description: 'ğŸ”¢ Agent B - License Plate (10.255.32.32)')
        booleanParam(name: 'AGENT_C', defaultValue: false, description: 'âš ï¸  Agent C - Hazard Detection (10.255.32.128)')
        booleanParam(name: 'STREAMING', defaultValue: false, description: 'ğŸ“¹ Streaming Middleware - Nginx RTMP (10.255.32.35)')
        booleanParam(name: 'KAFKA', defaultValue: false, description: 'ğŸ“¨ Kafka Broker (10.255.32.143)')
        booleanParam(name: 'DATA_MODULE', defaultValue: false, description: 'ğŸ’¾ Data Module + Databases (10.255.32.82)')
        booleanParam(name: 'DECISION_ENGINE', defaultValue: false, description: 'ğŸ§  Decision Engine (10.255.32.104)')
        booleanParam(name: 'API_GATEWAY', defaultValue: false, description: 'ğŸŒ API Gateway (10.255.32.100)')
        booleanParam(name: 'UI', defaultValue: false, description: 'ğŸ–¥ï¸  Frontend UI (10.255.32.108)')
        
        // ================================================================
        // OPÃ‡Ã•ES ADICIONAIS
        // ================================================================
        string(
            name: 'BRANCH',
            defaultValue: 'main',
            description: 'Git branch (para deploy)'
        )
        
        string(
            name: 'LOG_LINES',
            defaultValue: '100',
            description: 'NÃºmero de linhas de log a mostrar (para aÃ§Ã£o logs)'
        )
    }
    
    environment {
        // VM IPs - Mapeamento serviÃ§o â†’ VM
        AGENTA_IP = '10.255.32.134'
        AGENTB_IP = '10.255.32.32'
        AGENTC_IP = '10.255.32.128'
        STREAMING_IP = '10.255.32.80'
        KAFKA_IP = '10.255.32.143'
        DATA_MODULE_IP = '10.255.32.82'
        DECISION_ENGINE_IP = '10.255.32.104'
        API_GATEWAY_IP = '10.255.32.100'
        UI_IP = '10.255.32.108'
        
        // Repositories
        BACKEND_REPO = 'https://github.com/PEI-HAZARDS/IntelligentLogistics.git'
        APP_REPO = 'https://github.com/PEI-HAZARDS/IntelligentLogistics_APP.git'
    }
    
    stages {
        stage('ğŸ“‹ Validar SeleÃ§Ã£o') {
            steps {
                script {
                    // Expandir ALL_SERVICES
                    if (params.ALL_SERVICES) {
                        env.SEL_AGENT_A = 'true'
                        env.SEL_AGENT_B = 'true'
                        env.SEL_AGENT_C = 'true'
                        env.SEL_STREAMING = 'true'
                        env.SEL_KAFKA = 'true'
                        env.SEL_DATA_MODULE = 'true'
                        env.SEL_DECISION_ENGINE = 'true'
                        env.SEL_API_GATEWAY = 'true'
                        env.SEL_UI = 'true'
                    } else {
                        env.SEL_AGENT_A = params.AGENT_A.toString()
                        env.SEL_AGENT_B = params.AGENT_B.toString()
                        env.SEL_AGENT_C = params.AGENT_C.toString()
                        env.SEL_STREAMING = params.STREAMING.toString()
                        env.SEL_KAFKA = params.KAFKA.toString()
                        env.SEL_DATA_MODULE = params.DATA_MODULE.toString()
                        env.SEL_DECISION_ENGINE = params.DECISION_ENGINE.toString()
                        env.SEL_API_GATEWAY = params.API_GATEWAY.toString()
                        env.SEL_UI = params.UI.toString()
                    }
                    
                    // Verificar se algo foi selecionado
                    def anySelected = [
                        env.SEL_AGENT_A, env.SEL_AGENT_B, env.SEL_AGENT_C,
                        env.SEL_STREAMING, env.SEL_KAFKA, env.SEL_DATA_MODULE,
                        env.SEL_DECISION_ENGINE, env.SEL_API_GATEWAY, env.SEL_UI
                    ].any { it == 'true' }
                    
                    if (!anySelected) {
                        error "âŒ Nenhum serviÃ§o selecionado! Seleciona pelo menos um serviÃ§o."
                    }
                    
                    echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ›ï¸  PAINEL DE CONTROLO                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  AÃ§Ã£o: ${params.ACTION.toUpperCase().padRight(52)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ServiÃ§os selecionados:                                       â•‘
â•‘    ${env.SEL_AGENT_A == 'true' ? 'âœ…' : 'â¬œ'} Agent A           ${env.SEL_STREAMING == 'true' ? 'âœ…' : 'â¬œ'} Streaming                   â•‘
â•‘    ${env.SEL_AGENT_B == 'true' ? 'âœ…' : 'â¬œ'} Agent B           ${env.SEL_KAFKA == 'true' ? 'âœ…' : 'â¬œ'} Kafka                        â•‘
â•‘    ${env.SEL_AGENT_C == 'true' ? 'âœ…' : 'â¬œ'} Agent C           ${env.SEL_DATA_MODULE == 'true' ? 'âœ…' : 'â¬œ'} Data Module                  â•‘
â•‘    ${env.SEL_DECISION_ENGINE == 'true' ? 'âœ…' : 'â¬œ'} Decision Engine  ${env.SEL_API_GATEWAY == 'true' ? 'âœ…' : 'â¬œ'} API Gateway                  â•‘
â•‘    ${env.SEL_UI == 'true' ? 'âœ…' : 'â¬œ'} UI                                                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                }
            }
        }
        
        stage('ğŸ”Œ Verificar Conectividade') {
            when { expression { return params.ACTION != 'status' } }
            steps {
                script {
                    echo "ğŸ” Verificando conectividade Ã s VMs..."
                    
                    def vmChecks = [:]
                    
                    if (env.SEL_AGENT_A == 'true') vmChecks['Agent A'] = AGENTA_IP
                    if (env.SEL_AGENT_B == 'true') vmChecks['Agent B'] = AGENTB_IP
                    if (env.SEL_AGENT_C == 'true') vmChecks['Agent C'] = AGENTC_IP
                    if (env.SEL_STREAMING == 'true') vmChecks['Streaming'] = STREAMING_IP
                    if (env.SEL_KAFKA == 'true') vmChecks['Kafka'] = KAFKA_IP
                    if (env.SEL_DATA_MODULE == 'true') vmChecks['Data Module'] = DATA_MODULE_IP
                    if (env.SEL_DECISION_ENGINE == 'true') vmChecks['Decision Engine'] = DECISION_ENGINE_IP
                    if (env.SEL_API_GATEWAY == 'true') vmChecks['API Gateway'] = API_GATEWAY_IP
                    if (env.SEL_UI == 'true') vmChecks['UI'] = UI_IP
                    
                    vmChecks.each { name, ip ->
                        def result = sh(
                            script: "timeout 5 bash -c 'cat < /dev/null > /dev/tcp/${ip}/22' 2>/dev/null",
                            returnStatus: true
                        )
                        if (result != 0) {
                            error "âŒ NÃ£o foi possÃ­vel conectar a ${name} (${ip})"
                        }
                        echo "âœ… ${name} (${ip}) - AcessÃ­vel"
                    }
                }
            }
        }
        
        stage('ğŸ“¥ Checkout') {
            when { expression { return params.ACTION == 'deploy' } }
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: BACKEND_REPO]]
                ])
            }
        }
        
        // ================================================================
        // EXECUÃ‡ÃƒO PARALELA DE SERVIÃ‡OS
        // ================================================================
        stage('âš¡ Deploy Paralelo') {
            when { expression { return true } }
            steps {
                script {
                    def parallelStages = [:]
                    
                    // Agent A
                    if (env.SEL_AGENT_A == 'true') {
                        parallelStages['ğŸšš Agent A'] = {
                            executeAction('agentA', AGENTA_IP, 'src/agentA_microservice', 'agentA')
                        }
                    }
                    
                    // Agent B
                    if (env.SEL_AGENT_B == 'true') {
                        parallelStages['ğŸ”¢ Agent B'] = {
                            executeAction('agentB', AGENTB_IP, 'src/agentB_microservice', 'agentB')
                        }
                    }
                    
                    // Agent C
                    if (env.SEL_AGENT_C == 'true') {
                        parallelStages['âš ï¸ Agent C'] = {
                            executeAction('agentC', AGENTC_IP, 'src/agentC_microservice', 'agentC')
                        }
                    }
                    
                    // Streaming
                    if (env.SEL_STREAMING == 'true') {
                        parallelStages['ğŸ“¹ Streaming'] = {
                            executeAction('nginx-rtmp', STREAMING_IP, 'src/streaming_middleware', 'nginx-rtmp', '1935:1935,8080:8080')
                        }
                    }
                    
                    // Kafka
                    if (env.SEL_KAFKA == 'true') {
                        parallelStages['ğŸ“¨ Kafka'] = {
                            if (params.ACTION == 'deploy') {
                                deployKafka(KAFKA_IP)
                            } else {
                                executeActionMulti(['zookeeper', 'kafka', 'kafka-ui'], KAFKA_IP)
                            }
                        }
                    }
                    
                    // Data Module
                    if (env.SEL_DATA_MODULE == 'true') {
                        parallelStages['ğŸ’¾ Data Module'] = {
                            if (params.ACTION == 'deploy') {
                                deployDataModule(DATA_MODULE_IP)
                            } else {
                                executeActionMulti(['dm_postgres', 'dm_mongo', 'dm_redis', 'minio', 'dm_data_module'], DATA_MODULE_IP)
                            }
                        }
                    }
                    
                    // Decision Engine
                    if (env.SEL_DECISION_ENGINE == 'true') {
                        parallelStages['ğŸ§  Decision Engine'] = {
                            executeAction('decision-engine', DECISION_ENGINE_IP, 'src/decision_engine_microservice', 'decision-engine')
                        }
                    }
                    
                    // API Gateway
                    if (env.SEL_API_GATEWAY == 'true') {
                        parallelStages['ğŸŒ API Gateway'] = {
                            executeAction('api_gateway', API_GATEWAY_IP, 'src/api_gateway', 'api_gateway', '8000:8000')
                        }
                    }
                    
                    // UI
                    if (env.SEL_UI == 'true') {
                        parallelStages['ğŸ–¥ï¸ UI'] = {
                            if (params.ACTION == 'deploy') {
                                deployUI(UI_IP)
                            } else {
                                executeAction('ui_il', UI_IP, null, 'ui_il')
                            }
                        }
                    }
                    
                    // Executar tudo em paralelo
                    if (parallelStages.size() > 0) {
                        parallel parallelStages
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              âœ… OPERAÃ‡ÃƒO CONCLUÃDA COM SUCESSO                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        }
        failure {
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âŒ OPERAÃ‡ÃƒO FALHOU                         â•‘
â•‘                  Ver logs acima para detalhes                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        }
        always {
            cleanWs()
        }
    }
}

// ============================================================================
// FUNÃ‡Ã•ES AUXILIARES
// ============================================================================

def executeAction(String containerName, String vmIp, String buildPath, String imageName, String ports = '') {
    /**
     * Executa a aÃ§Ã£o selecionada num container especÃ­fico
     */
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        def sshCmd = "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${vmIp}"
        
        switch(params.ACTION) {
            case 'status':
                echo "ğŸ“Š Estado de ${containerName} em ${vmIp}:"
                sh """
                    SSH_DIR="\${HOME}/.ssh"
                    mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                    ${sshCmd} 'docker ps -a --filter name=${containerName} --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\\t{{.Image}}"'
                """
                break
                
            case 'logs':
                echo "ğŸ“œ Logs de ${containerName} em ${vmIp}:"
                sh """
                    SSH_DIR="\${HOME}/.ssh"
                    mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                    ${sshCmd} 'docker logs --tail ${params.LOG_LINES} ${containerName} 2>&1' || echo "Container nÃ£o encontrado ou sem logs"
                """
                break
                
            case 'restart':
                echo "ğŸ”„ Reiniciando ${containerName} em ${vmIp}..."
                sh """
                    SSH_DIR="\${HOME}/.ssh"
                    mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                    ${sshCmd} 'docker restart ${containerName}'
                """
                echo "âœ… ${containerName} reiniciado"
                break
                
            case 'stop':
                echo "â¹ï¸ Parando ${containerName} em ${vmIp}..."
                sh """
                    SSH_DIR="\${HOME}/.ssh"
                    mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                    ${sshCmd} 'docker stop ${containerName}'
                """
                echo "âœ… ${containerName} parado"
                break
                
            case 'deploy':
                echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“¦ Deploy: ${containerName.padRight(48)}â•‘
â•‘  ğŸ–¥ï¸  VM: ${vmIp.padRight(51)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                
                def buildOutput = sh(
                    script: """
                        SSH_DIR="\${HOME}/.ssh"
                        mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                        
                        cat > "\${SSH_DIR}/config" << EOF
Host ${containerName}-vm
    HostName ${vmIp}
    User \$SSH_USER
    IdentityFile \${SSH_DIR}/deploy_key
    StrictHostKeyChecking no
    UserKnownHostsFile=/dev/null
EOF
                        
                        docker context create ${containerName}_ctx --docker "host=ssh://${containerName}-vm" 2>/dev/null || true
                        docker context use ${containerName}_ctx
                        
                        echo "ğŸ” Verificando imagem existente..."
                        OLD_IMAGE_ID=\$(docker images -q ${imageName}:latest 2>/dev/null || echo "none")
                        echo "   Imagem anterior: \$OLD_IMAGE_ID"
                        
                        cd ${buildPath}
                        
                        echo ""
                        echo "ğŸ”¨ Iniciando build..."
                        docker compose build 2>/dev/null || docker build -t ${imageName}:latest . 2>&1 | tee /tmp/build_${containerName}.log
                        
                        NEW_IMAGE_ID=\$(docker images -q ${imageName}:latest)
                        echo ""
                        echo "   Imagem nova: \$NEW_IMAGE_ID"
                        
                        if [ "\$OLD_IMAGE_ID" = "\$NEW_IMAGE_ID" ] && [ "\$OLD_IMAGE_ID" != "none" ]; then
                            echo ""
                            echo "âœ¨ CACHE COMPLETO - Nenhuma layer foi reconstruÃ­da"
                            echo "   (Imagem nÃ£o mudou, tudo reutilizado do cache)"
                        else
                            echo ""
                            echo "ğŸ”„ BUILD REALIZADO - Layers foram reconstruÃ­das"
                            
                            # AnÃ¡lise do log de build para mostrar o que mudou
                            if grep -q "CACHED" /tmp/build_${containerName}.log 2>/dev/null; then
                                CACHED_STEPS=\$(grep -c "CACHED" /tmp/build_${containerName}.log)
                                echo "   âœ… \$CACHED_STEPS steps reutilizados do cache"
                            fi
                            
                            if grep -qE "RUN|COPY" /tmp/build_${containerName}.log 2>/dev/null; then
                                REBUILT_STEPS=\$(grep -cE "Step [0-9]+/[0-9]+ : (RUN|COPY)" /tmp/build_${containerName}.log | grep -v CACHED || echo "0")
                                if [ "\$REBUILT_STEPS" != "0" ]; then
                                    echo "   ğŸ”¨ \$REBUILT_STEPS steps reconstruÃ­dos"
                                fi
                            fi
                        fi
                        
                        echo ""
                        echo "ğŸ”„ Atualizando container..."
                        docker stop ${containerName} 2>/dev/null || true
                        docker rm ${containerName} 2>/dev/null || true
                        
                        docker compose up -d 2>/dev/null || docker run -d \\
                            --name ${containerName} \\
                            --restart unless-stopped \\
                            ${ports ? ports.split(',').collect { "-p ${it}" }.join(' ') : ''} \\
                            ${imageName}:latest
                        
                        echo ""
                        echo "ğŸ“Š Status final:"
                        docker ps --filter name=${containerName} --format "   ID: {{.ID}} | Status: {{.Status}} | Ports: {{.Ports}}"
                        
                        docker context use default
                        
                        rm -f /tmp/build_${containerName}.log
                    """,
                    returnStdout: true
                )
                
                echo buildOutput
                
                echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  âœ… ${containerName.padRight(48)} DEPLOYED    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                break
        }
    }
}

def executeActionMulti(List<String> containers, String vmIp) {
    /**
     * Executa a aÃ§Ã£o em mÃºltiplos containers (ex: Kafka tem 3 containers)
     */
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        def sshCmd = "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${vmIp}"
        
        switch(params.ACTION) {
            case 'status':
                echo "ğŸ“Š Estado dos containers em ${vmIp}:"
                sh """
                    SSH_DIR="\${HOME}/.ssh"
                    mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                    ${sshCmd} 'docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"'
                """
                break
                
            case 'logs':
                containers.each { container ->
                    echo "ğŸ“œ Logs de ${container}:"
                    sh """
                        SSH_DIR="\${HOME}/.ssh"
                        mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                        ${sshCmd} 'docker logs --tail ${params.LOG_LINES} ${container} 2>&1' || echo "Container nÃ£o encontrado"
                    """
                }
                break
                
            case 'restart':
                echo "ğŸ”„ Reiniciando containers em ${vmIp}..."
                containers.each { container ->
                    sh """
                        SSH_DIR="\${HOME}/.ssh"
                        mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                        ${sshCmd} 'docker restart ${container} 2>/dev/null' || echo "${container} nÃ£o encontrado"
                    """
                }
                echo "âœ… Containers reiniciados"
                break
                
            case 'stop':
                echo "â¹ï¸ Parando containers em ${vmIp}..."
                containers.reverse().each { container ->
                    sh """
                        SSH_DIR="\${HOME}/.ssh"
                        mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
                        ${sshCmd} 'docker stop ${container} 2>/dev/null' || echo "${container} nÃ£o encontrado"
                    """
                }
                echo "âœ… Containers parados"
                break
        }
    }
}

def deployKafka(String vmIp) {
    echo "ğŸ“¦ Deploying Kafka stack to ${vmIp}..."
    
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        sh """
            SSH_DIR="\${HOME}/.ssh"
            mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
            
            ssh -i "\${SSH_DIR}/deploy_key" -o StrictHostKeyChecking=no \$SSH_USER@${vmIp} << 'ENDSSH'
                docker network create kafka-net 2>/dev/null || true
                
                # Para containers mas nÃ£o remove (mantÃ©m volumes)
                docker stop kafka kafka-ui zookeeper 2>/dev/null || true
                docker rm kafka kafka-ui zookeeper 2>/dev/null || true
                
                docker run -d --name zookeeper --network kafka-net --restart unless-stopped \\
                    -e ZOOKEEPER_CLIENT_PORT=2181 \\
                    confluentinc/cp-zookeeper:latest
                
                sleep 10
                
                docker run -d --name kafka --network kafka-net --restart unless-stopped \\
                    -p 9092:9092 \\
                    -e KAFKA_BROKER_ID=1 \\
                    -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\
                    -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://${vmIp}:9092 \\
                    -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \\
                    confluentinc/cp-kafka:latest
                
                sleep 10
                
                docker run -d --name kafka-ui --network kafka-net --restart unless-stopped \\
                    -p 8080:8080 \\
                    -e KAFKA_CLUSTERS_0_NAME=intelligent-logistics \\
                    -e KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9092 \\
                    provectuslabs/kafka-ui:latest
                
                echo "âœ… Kafka stack deployed"
ENDSSH
        """
    }
}

def deployDataModule(String vmIp) {
    echo "ğŸ“¦ Deploying Data Module stack to ${vmIp}..."
    
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER'),
        usernamePassword(credentialsId: 'minio-credentials', usernameVariable: 'MINIO_USER', passwordVariable: 'MINIO_PASS')
    ]) {
        sh """
            SSH_DIR="\${HOME}/.ssh"
            mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
            
            # Copiar docker-compose para a VM
            scp -i "\${SSH_DIR}/deploy_key" -o StrictHostKeyChecking=no \\
                src/Data_Module/docker-compose.yml \\
                \$SSH_USER@${vmIp}:~/data-module/
            
            ssh -i "\${SSH_DIR}/deploy_key" -o StrictHostKeyChecking=no \$SSH_USER@${vmIp} << ENDSSH
                cd ~/data-module
                
                # Para mas mantÃ©m volumes (dados persistentes)
                docker compose down --volumes=false 2>/dev/null || true
                
                # Up com build cache automÃ¡tico
                docker compose up -d --build
                
                echo "âœ… Data Module stack deployed"
ENDSSH
        """
        
        // Deploy da aplicaÃ§Ã£o Data Module
        sh """
            docker context create data_module_ctx --docker "host=ssh://\$SSH_USER@${vmIp}" 2>/dev/null || true
            docker context use data_module_ctx
            
            cd src/Data_Module
            
            # Build com cache automÃ¡tico
            docker compose build
            
            # Para mas nÃ£o remove volumes
            docker compose stop
            
            # Up
            docker compose up -d
            
            docker context use default
        """
    }
}

def deployUI(String vmIp) {
    echo "ğŸ“¦ Deploying UI to ${vmIp}..."
    
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        // Checkout do repo da APP
        dir('app') {
            checkout([
                $class: 'GitSCM',
                branches: [[name: "*/${params.BRANCH}"]],
                userRemoteConfigs: [[url: APP_REPO]]
            ])
        }
        
        sh """
            SSH_DIR="\${HOME}/.ssh"
            mkdir -p "\${SSH_DIR}" && cp \$SSH_KEY "\${SSH_DIR}/deploy_key" && chmod 600 "\${SSH_DIR}/deploy_key"
            
            docker context create ui_ctx --docker "host=ssh://\$SSH_USER@${vmIp}" 2>/dev/null || true
            docker context use ui_ctx
            
            cd app
            
            # Build com cache automÃ¡tico de layers
            docker build -t ui_il:latest .
            
            # Para mas nÃ£o remove (pode ter volumes de config)
            docker stop ui_il 2>/dev/null || true
            docker rm ui_il 2>/dev/null || true
            
            docker run -d --name ui_il --restart unless-stopped -p 3000:3000 ui_il:latest
            
            echo "âœ… UI deployed"
            docker context use default
        """
    }
}
