/**
 * IntelligentLogistics - Jenkins Control Panel
 * 
 * Interface centralizada para gerir todos os serviÃ§os nas diferentes VMs.
 * 
 * AÃ§Ãµes disponÃ­veis:
 * - deploy: Build e deploy do serviÃ§o
 * - status: Ver estado dos containers
 * - logs: Ver logs do container
 * - restart: Reiniciar container
 * - stop: Parar container
 * 
 * Setup inicial (uma vez):
 *   1. Gerar chaves SSH no container Jenkins:
 *      docker exec jenkins ssh-keygen -t ed25519 -f /var/jenkins_home/.ssh/id_ed25519 -N ""
 *   2. Obter chave pÃºblica:
 *      docker exec jenkins cat /var/jenkins_home/.ssh/id_ed25519.pub
 *   3. Adicionar a chave pÃºblica em cada VM:
 *      ssh pei_user@<VM_IP> "echo '<CHAVE_PUBLICA>' >> ~/.ssh/authorized_keys"
 */

pipeline {
    agent any
    
    parameters {
        // ================================================================
        // AÃ‡ÃƒO A EXECUTAR
        // ================================================================
        choice(
            name: 'ACTION',
            choices: ['status', 'deploy', 'restart', 'stop', 'logs'],
            description: '''
                status  â†’ Ver estado dos containers selecionados
                deploy  â†’ Build e deploy dos serviÃ§os selecionados
                restart â†’ Reiniciar containers selecionados
                stop    â†’ Parar containers selecionados
                logs    â†’ Ver logs dos containers selecionados
            '''
        )
        
        // ================================================================
        // SELEÃ‡ÃƒO DE SERVIÃ‡OS (checkboxes)
        // ================================================================
        booleanParam(name: 'ALL_SERVICES', defaultValue: false, description: 'Selecionar TODOS')
        
        booleanParam(name: 'AGENT_A', defaultValue: false, description: 'Agent A (10.255.32.134)')
        booleanParam(name: 'AGENT_B', defaultValue: false, description: 'Agent B (10.255.32.32)')
        booleanParam(name: 'AGENT_C', defaultValue: false, description: 'Agent C (10.255.32.128)')
        booleanParam(name: 'STREAMING', defaultValue: false, description: 'Streaming (10.255.32.80)')
        booleanParam(name: 'KAFKA', defaultValue: false, description: 'Kafka (10.255.32.143)')
        booleanParam(name: 'DATA_MODULE', defaultValue: false, description: 'Data Module (10.255.32.82)')
        booleanParam(name: 'DECISION_ENGINE', defaultValue: false, description: 'Decision Engine (10.255.32.104)')
        booleanParam(name: 'API_GATEWAY', defaultValue: false, description: 'API Gateway (10.255.32.100)')
        booleanParam(name: 'UI', defaultValue: false, description: 'UI (10.255.32.108)')
        
        // ================================================================
        // OPÃ‡Ã•ES ADICIONAIS
        // ================================================================
        string(
            name: 'BRANCH',
            defaultValue: 'main',
            description: 'Git branch do Backend (apenas para deploy)'
        )
        
        string(
            name: 'UI_BRANCH',
            defaultValue: 'main',
            description: 'Git branch da UI/APP (apenas para deploy da UI)'
        )
        
        string(
            name: 'LOG_LINES',
            defaultValue: '100',
            description: 'Linhas de log a mostrar (apenas para aÃ§Ã£o logs)'
        )
    }
    
    environment {
        // VM IPs - Mapeamento serviÃ§o â†’ VM
        AGENTA_IP = '10.255.32.134'
        AGENTB_IP = '10.255.32.32'
        AGENTC_IP = '10.255.32.128'
        STREAMING_IP = '10.255.32.80'
        KAFKA_IP = '10.255.32.143'
        DATA_MODULE_IP = '10.255.32.82'
        DECISION_ENGINE_IP = '10.255.32.104'
        API_GATEWAY_IP = '10.255.32.100'
        UI_IP = '10.255.32.108'
        
        // SSH User para acesso Ã s VMs
        SSH_USER = 'pei_user'
        
        // Repositories
        BACKEND_REPO = 'https://github.com/PEI-HAZARDS/IntelligentLogistics.git'
        APP_REPO = 'https://github.com/PEI-HAZARDS/IntelligentLogistics_APP.git'
        
        // Jenkins Credentials IDs para os .env de cada serviÃ§o
        // Configurar no Jenkins: Manage Jenkins â†’ Credentials â†’ Add "Secret file"
        // ID sugerido: env-<serviÃ§o> (ex: env-agenta, env-datamodule)
        ENV_CREDENTIALS_ENABLED = 'true'  // Mudar para 'false' se .env jÃ¡ estiver nas VMs
    }
    
    stages {
        stage('ğŸ“‹ Validar SeleÃ§Ã£o') {
            steps {
                script {
                    // Expandir ALL_SERVICES
                    if (params.ALL_SERVICES) {
                        env.SEL_AGENT_A = 'true'
                        env.SEL_AGENT_B = 'true'
                        env.SEL_AGENT_C = 'true'
                        env.SEL_STREAMING = 'true'
                        env.SEL_KAFKA = 'true'
                        env.SEL_DATA_MODULE = 'true'
                        env.SEL_DECISION_ENGINE = 'true'
                        env.SEL_API_GATEWAY = 'true'
                        env.SEL_UI = 'true'
                    } else {
                        env.SEL_AGENT_A = params.AGENT_A.toString()
                        env.SEL_AGENT_B = params.AGENT_B.toString()
                        env.SEL_AGENT_C = params.AGENT_C.toString()
                        env.SEL_STREAMING = params.STREAMING.toString()
                        env.SEL_KAFKA = params.KAFKA.toString()
                        env.SEL_DATA_MODULE = params.DATA_MODULE.toString()
                        env.SEL_DECISION_ENGINE = params.DECISION_ENGINE.toString()
                        env.SEL_API_GATEWAY = params.API_GATEWAY.toString()
                        env.SEL_UI = params.UI.toString()
                    }
                    
                    // Verificar se algo foi selecionado
                    def anySelected = [
                        env.SEL_AGENT_A, env.SEL_AGENT_B, env.SEL_AGENT_C,
                        env.SEL_STREAMING, env.SEL_KAFKA, env.SEL_DATA_MODULE,
                        env.SEL_DECISION_ENGINE, env.SEL_API_GATEWAY, env.SEL_UI
                    ].any { it == 'true' }
                    
                    if (!anySelected) {
                        error "âŒ Nenhum serviÃ§o selecionado! Seleciona pelo menos um serviÃ§o."
                    }
                    
                    // Info contextual baseada na aÃ§Ã£o
                    def extraInfo = ""
                    if (params.ACTION == 'deploy') {
                        extraInfo = "â•‘  Branch Backend: ${params.BRANCH.padRight(44)}â•‘"
                        if (env.SEL_UI == 'true') {
                            extraInfo += "\nâ•‘  Branch UI:      ${params.UI_BRANCH.padRight(44)}â•‘"
                        }
                    } else if (params.ACTION == 'logs') {
                        extraInfo = "â•‘  Linhas: ${params.LOG_LINES.padRight(52)}â•‘"
                    }
                    
                    echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ›ï¸  PAINEL DE CONTROLO                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  AÃ§Ã£o: ${params.ACTION.toUpperCase().padRight(52)}â•‘
${extraInfo ? extraInfo + '\n' : ''}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ServiÃ§os selecionados:                                       â•‘
â•‘    ${env.SEL_AGENT_A == 'true' ? 'âœ…' : 'â¬œ'} Agent A           ${env.SEL_STREAMING == 'true' ? 'âœ…' : 'â¬œ'} Streaming                   â•‘
â•‘    ${env.SEL_AGENT_B == 'true' ? 'âœ…' : 'â¬œ'} Agent B           ${env.SEL_KAFKA == 'true' ? 'âœ…' : 'â¬œ'} Kafka                        â•‘
â•‘    ${env.SEL_AGENT_C == 'true' ? 'âœ…' : 'â¬œ'} Agent C           ${env.SEL_DATA_MODULE == 'true' ? 'âœ…' : 'â¬œ'} Data Module                  â•‘
â•‘    ${env.SEL_DECISION_ENGINE == 'true' ? 'âœ…' : 'â¬œ'} Decision Engine  ${env.SEL_API_GATEWAY == 'true' ? 'âœ…' : 'â¬œ'} API Gateway                  â•‘
â•‘    ${env.SEL_UI == 'true' ? 'âœ…' : 'â¬œ'} UI                                                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                }
            }
        }
        
        stage('ğŸ”Œ Verificar Conectividade') {
            when { expression { return params.ACTION != 'status' } }
            steps {
                script {
                    echo "ğŸ” Verificando conectividade Ã s VMs..."
                    
                    def vmChecks = [:]
                    
                    if (env.SEL_AGENT_A == 'true') vmChecks['Agent A'] = AGENTA_IP
                    if (env.SEL_AGENT_B == 'true') vmChecks['Agent B'] = AGENTB_IP
                    if (env.SEL_AGENT_C == 'true') vmChecks['Agent C'] = AGENTC_IP
                    if (env.SEL_STREAMING == 'true') vmChecks['Streaming'] = STREAMING_IP
                    if (env.SEL_KAFKA == 'true') vmChecks['Kafka'] = KAFKA_IP
                    if (env.SEL_DATA_MODULE == 'true') vmChecks['Data Module'] = DATA_MODULE_IP
                    if (env.SEL_DECISION_ENGINE == 'true') vmChecks['Decision Engine'] = DECISION_ENGINE_IP
                    if (env.SEL_API_GATEWAY == 'true') vmChecks['API Gateway'] = API_GATEWAY_IP
                    if (env.SEL_UI == 'true') vmChecks['UI'] = UI_IP
                    
                    vmChecks.each { name, ip ->
                        def result = sh(
                            script: "timeout 5 bash -c 'cat < /dev/null > /dev/tcp/${ip}/22' 2>/dev/null",
                            returnStatus: true
                        )
                        if (result != 0) {
                            error "âŒ NÃ£o foi possÃ­vel conectar a ${name} (${ip})"
                        }
                        echo "âœ… ${name} (${ip}) - AcessÃ­vel"
                    }
                }
            }
        }
        
        stage('ğŸ“¥ Checkout') {
            when { expression { return params.ACTION == 'deploy' } }
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: BACKEND_REPO]]
                ])
            }
        }
        
        // ================================================================
        // EXECUÃ‡ÃƒO PARALELA DE SERVIÃ‡OS
        // ================================================================
        stage('âš¡ Deploy Paralelo') {
            when { expression { return true } }
            steps {
                script {
                    def parallelStages = [:]
                    
                    // Agent A
                    if (env.SEL_AGENT_A == 'true') {
                        parallelStages['ğŸšš Agent A'] = {
                            executeAction('agenta', AGENTA_IP, 'src/agentA_microservice', 'agenta')
                        }
                    }
                    
                    // Agent B
                    if (env.SEL_AGENT_B == 'true') {
                        parallelStages['ğŸ”¢ Agent B'] = {
                            executeAction('agentb', AGENTB_IP, 'src/agentB_microservice', 'agentb')
                        }
                    }
                    
                    // Agent C
                    if (env.SEL_AGENT_C == 'true') {
                        parallelStages['âš ï¸ Agent C'] = {
                            executeAction('agentc', AGENTC_IP, 'src/agentC_microservice', 'agentc')
                        }
                    }
                    
                    // Streaming
                    if (env.SEL_STREAMING == 'true') {
                        parallelStages['ğŸ“¹ Streaming'] = {
                            executeAction('nginx-rtmp', STREAMING_IP, 'src/streaming_middleware', 'nginx-rtmp', '1935:1935,8080:8080')
                        }
                    }
                    
                    // Kafka
                    if (env.SEL_KAFKA == 'true') {
                        parallelStages['ğŸ“¨ Kafka'] = {
                            if (params.ACTION == 'deploy') {
                                deployKafka(KAFKA_IP)
                            } else {
                                executeActionMulti(['zookeeper', 'kafka', 'kafka-ui'], KAFKA_IP)
                            }
                        }
                    }
                    
                    // Data Module
                    if (env.SEL_DATA_MODULE == 'true') {
                        parallelStages['ğŸ’¾ Data Module'] = {
                            if (params.ACTION == 'deploy') {
                                deployDataModule(DATA_MODULE_IP)
                            } else {
                                executeActionMulti(['dm_postgres', 'dm_mongo', 'dm_redis', 'minio', 'dm_data_module'], DATA_MODULE_IP)
                            }
                        }
                    }
                    
                    // Decision Engine
                    if (env.SEL_DECISION_ENGINE == 'true') {
                        parallelStages['ğŸ§  Decision Engine'] = {
                            executeAction('decision-engine', DECISION_ENGINE_IP, 'src/decision_engine_microservice', 'decision-engine')
                        }
                    }
                    
                    // API Gateway
                    if (env.SEL_API_GATEWAY == 'true') {
                        parallelStages['ğŸŒ API Gateway'] = {
                            executeAction('api_gateway', API_GATEWAY_IP, 'src/api_gateway', 'api_gateway', '8000:8000')
                        }
                    }
                    
                    // UI
                    if (env.SEL_UI == 'true') {
                        parallelStages['ğŸ–¥ï¸ UI'] = {
                            if (params.ACTION == 'deploy') {
                                deployUI(UI_IP)
                            } else {
                                executeAction('ui_il', UI_IP, null, 'ui_il')
                            }
                        }
                    }
                    
                    // Executar tudo em paralelo
                    if (parallelStages.size() > 0) {
                        parallel parallelStages
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              âœ… OPERAÃ‡ÃƒO CONCLUÃDA COM SUCESSO                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        }
        failure {
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âŒ OPERAÃ‡ÃƒO FALHOU                         â•‘
â•‘                  Ver logs acima para detalhes                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        }
        always {
            cleanWs()
        }
    }
}

// ============================================================================
// FUNÃ‡Ã•ES AUXILIARES
// ============================================================================

def executeAction(String containerName, String vmIp, String buildPath, String imageName, String ports = '') {
    /**
     * Executa a aÃ§Ã£o selecionada num container especÃ­fico.
     * Usa chaves SSH persistentes em /var/jenkins_home/.ssh/
     */
    def dockerHost = "ssh://${SSH_USER}@${vmIp}"
    
    switch(params.ACTION) {
        case 'status':
            echo "ğŸ“Š Estado de ${containerName} em ${vmIp}:"
            sh """
                docker -H "${dockerHost}" ps -a --filter name=${containerName} --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\\t{{.Image}}"
            """
            break
            
        case 'logs':
            echo "ğŸ“œ Logs de ${containerName} em ${vmIp}:"
            sh """
                docker -H "${dockerHost}" logs --tail ${params.LOG_LINES} ${containerName} 2>&1 || echo "Container nÃ£o encontrado ou sem logs"
            """
            break
            
        case 'restart':
            echo "ğŸ”„ Reiniciando ${containerName} em ${vmIp}..."
            sh """
                docker -H "${dockerHost}" restart ${containerName}
            """
            echo "âœ… ${containerName} reiniciado"
            break
            
        case 'stop':
            echo "â¹ï¸ Parando ${containerName} em ${vmIp}..."
            sh """
                docker -H "${dockerHost}" stop ${containerName}
            """
            echo "âœ… ${containerName} parado"
            break
            
        case 'deploy':
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“¦ Deploy: ${containerName.padRight(48)}â•‘
â•‘  ğŸ–¥ï¸  VM: ${vmIp.padRight(51)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
            
            // Injectar .env do Jenkins Credentials (se configurado)
            def envCredentialId = "env-${containerName}"
            def envFileExists = false
            
            if (env.ENV_CREDENTIALS_ENABLED == 'true') {
                try {
                    withCredentials([file(credentialsId: envCredentialId, variable: 'ENV_FILE')]) {
                        sh "cp \$ENV_FILE ${buildPath}/.env"
                        echo "âœ… .env injectado do Jenkins Credentials (${envCredentialId})"
                        envFileExists = true
                    }
                } catch (Exception e) {
                    echo "âš ï¸  Credential '${envCredentialId}' nÃ£o encontrada - usando .env existente (se houver)"
                }
            }
            
            def buildOutput = sh(
                script: """
                    echo "ğŸ” Verificando imagem existente..."
                    OLD_IMAGE_ID=\$(docker -H "${dockerHost}" images -q ${imageName}:latest 2>/dev/null || echo "none")
                    echo "   Imagem anterior: \$OLD_IMAGE_ID"
                    
                    cd ${buildPath}
                    
                    echo ""
                    echo "ğŸ”¨ Iniciando build..."
                    docker -H "${dockerHost}" compose build 2>&1 | tee /tmp/build_${containerName}.log || \
                    docker -H "${dockerHost}" build -t ${imageName}:latest . 2>&1 | tee /tmp/build_${containerName}.log
                    
                    NEW_IMAGE_ID=\$(docker -H "${dockerHost}" images -q ${imageName}:latest)
                    echo ""
                    echo "   Imagem nova: \$NEW_IMAGE_ID"
                    
                    if [ "\$OLD_IMAGE_ID" = "\$NEW_IMAGE_ID" ] && [ "\$OLD_IMAGE_ID" != "none" ]; then
                        echo ""
                        echo "âœ¨ CACHE COMPLETO - Nenhuma layer foi reconstruÃ­da"
                        echo "   (Imagem nÃ£o mudou, tudo reutilizado do cache)"
                    else
                        echo ""
                        echo "ğŸ”„ BUILD REALIZADO - Layers foram reconstruÃ­das"
                        
                        # AnÃ¡lise do log de build para mostrar o que mudou
                        if grep -q "CACHED" /tmp/build_${containerName}.log 2>/dev/null; then
                            CACHED_STEPS=\$(grep -c "CACHED" /tmp/build_${containerName}.log)
                            echo "   âœ… \$CACHED_STEPS steps reutilizados do cache"
                        fi
                    fi
                    
                    echo ""
                    echo "ğŸ”„ Atualizando container..."
                    docker -H "${dockerHost}" stop ${containerName} 2>/dev/null || true
                    docker -H "${dockerHost}" rm ${containerName} 2>/dev/null || true
                    
                    docker -H "${dockerHost}" compose up -d 2>/dev/null || docker -H "${dockerHost}" run -d \\
                        --name ${containerName} \\
                        --restart unless-stopped \\
                        ${ports ? ports.split(',').collect { "-p ${it}" }.join(' ') : ''} \\
                        ${imageName}:latest
                    
                    echo ""
                    echo "ğŸ“Š Status final:"
                    docker -H "${dockerHost}" ps --filter name=${containerName} --format "   ID: {{.ID}} | Status: {{.Status}} | Ports: {{.Ports}}"
                    
                    rm -f /tmp/build_${containerName}.log
                """,
                returnStdout: true
            )
            
            echo buildOutput
            
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  âœ… ${containerName.padRight(48)} DEPLOYED    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
            break
    }
}

def executeActionMulti(List<String> containers, String vmIp) {
    /**
     * Executa a aÃ§Ã£o em mÃºltiplos containers (ex: Kafka tem 3 containers).
     * Usa chaves SSH persistentes em /var/jenkins_home/.ssh/
     */
    def dockerHost = "ssh://${SSH_USER}@${vmIp}"
    
    switch(params.ACTION) {
        case 'status':
            echo "ğŸ“Š Estado dos containers em ${vmIp}:"
            sh """
                docker -H "${dockerHost}" ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"
            """
            break
            
        case 'logs':
            containers.each { container ->
                echo "ğŸ“œ Logs de ${container}:"
                sh """
                    docker -H "${dockerHost}" logs --tail ${params.LOG_LINES} ${container} 2>&1 || echo "Container nÃ£o encontrado"
                """
            }
            break
            
        case 'restart':
            echo "ğŸ”„ Reiniciando containers em ${vmIp}..."
            containers.each { container ->
                sh """
                    docker -H "${dockerHost}" restart ${container} 2>/dev/null || echo "${container} nÃ£o encontrado"
                """
            }
            echo "âœ… Containers reiniciados"
            break
            
        case 'stop':
            echo "â¹ï¸ Parando containers em ${vmIp}..."
            containers.reverse().each { container ->
                sh """
                    docker -H "${dockerHost}" stop ${container} 2>/dev/null || echo "${container} nÃ£o encontrado"
                """
            }
            echo "âœ… Containers parados"
            break
    }
}

def deployKafka(String vmIp) {
    echo "ğŸ“¦ Deploying Kafka stack to ${vmIp}..."
    
    def dockerHost = "ssh://${SSH_USER}@${vmIp}"
    
    sh """
        docker -H "${dockerHost}" network create kafka-net 2>/dev/null || true
        
        # Para containers mas nÃ£o remove (mantÃ©m volumes)
        docker -H "${dockerHost}" stop kafka kafka-ui zookeeper 2>/dev/null || true
        docker -H "${dockerHost}" rm kafka kafka-ui zookeeper 2>/dev/null || true
        
        docker -H "${dockerHost}" run -d --name zookeeper --network kafka-net --restart unless-stopped \\
            -e ZOOKEEPER_CLIENT_PORT=2181 \\
            confluentinc/cp-zookeeper:latest
        
        sleep 10
        
        docker -H "${dockerHost}" run -d --name kafka --network kafka-net --restart unless-stopped \\
            -p 9092:9092 \\
            -e KAFKA_BROKER_ID=1 \\
            -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\
            -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://${vmIp}:9092 \\
            -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \\
            confluentinc/cp-kafka:latest
        
        sleep 10
        
        docker -H "${dockerHost}" run -d --name kafka-ui --network kafka-net --restart unless-stopped \\
            -p 8080:8080 \\
            -e KAFKA_CLUSTERS_0_NAME=intelligent-logistics \\
            -e KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9092 \\
            provectuslabs/kafka-ui:latest
        
        echo "âœ… Kafka stack deployed"
    """
}

def deployDataModule(String vmIp) {
    echo "ğŸ“¦ Deploying Data Module stack to ${vmIp}..."
    
    def dockerHost = "ssh://${SSH_USER}@${vmIp}"
    
    // Copiar docker-compose para a VM
    sh """
        scp -o StrictHostKeyChecking=no \\
            src/Data_Module/docker-compose.yml \\
            ${SSH_USER}@${vmIp}:~/data-module/
    """
    
    // Deploy via SSH
    sh """
        ssh -o StrictHostKeyChecking=no ${SSH_USER}@${vmIp} << 'ENDSSH'
            cd ~/data-module
            
            # Para mas mantÃ©m volumes (dados persistentes)
            docker compose down --volumes=false 2>/dev/null || true
            
            # Up com build cache automÃ¡tico
            docker compose up -d --build
            
            echo "âœ… Data Module stack deployed"
ENDSSH
    """
}

def deployUI(String vmIp) {
    echo "ğŸ“¦ Deploying UI to ${vmIp}..."
    
    def dockerHost = "ssh://${SSH_USER}@${vmIp}"
    
    // Checkout do repo da APP (usa UI_BRANCH separada)
    dir('app') {
        checkout([
            $class: 'GitSCM',
            branches: [[name: "*/${params.UI_BRANCH}"]],
            userRemoteConfigs: [[url: APP_REPO]]
        ])
    }
    
    sh """
        cd app
        
        # Build com cache automÃ¡tico de layers
        docker -H "${dockerHost}" build -t ui_il:latest .
        
        # Para mas nÃ£o remove (pode ter volumes de config)
        docker -H "${dockerHost}" stop ui_il 2>/dev/null || true
        docker -H "${dockerHost}" rm ui_il 2>/dev/null || true
        
        docker -H "${dockerHost}" run -d --name ui_il --restart unless-stopped -p 3000:3000 ui_il:latest
        
        echo "âœ… UI deployed"
    """
}
