/**
 * IntelligentLogistics - Jenkins Control Panel
 * 
 * Interface centralizada para gerir todos os serviÃ§os nas diferentes VMs.
 * 
 * AÃ§Ãµes disponÃ­veis:
 * - deploy: Build e deploy do serviÃ§o
 * - status: Ver estado dos containers
 * - logs: Ver logs do container
 * - restart: Reiniciar container
 * - stop: Parar container
 * 
 * Jenkins Credentials:
 * - ssh-vm-key: SSH key para acesso Ã s VMs
 * - minio-credentials: MinIO username/password
 */

pipeline {
    agent any
    
    parameters {
        // ================================================================
        // AÃ‡ÃƒO A EXECUTAR
        // ================================================================
        choice(
            name: 'ACTION',
            choices: ['status', 'deploy', 'restart', 'stop', 'logs'],
            description: '''
                status  â†’ Ver estado dos containers selecionados
                deploy  â†’ Build e deploy dos serviÃ§os selecionados
                restart â†’ Reiniciar containers selecionados
                stop    â†’ Parar containers selecionados
                logs    â†’ Ver logs dos containers selecionados
            '''
        )
        
        // ================================================================
        // SELEÃ‡ÃƒO DE SERVIÃ‡OS (checkboxes)
        // ================================================================
        booleanParam(name: 'ALL_SERVICES', defaultValue: false, description: 'âš¡ Selecionar TODOS os serviÃ§os')
        
        booleanParam(name: 'AGENT_A', defaultValue: false, description: 'ðŸšš Agent A - Truck Detection (10.255.32.134)')
        booleanParam(name: 'AGENT_B', defaultValue: false, description: 'ðŸ”¢ Agent B - License Plate (10.255.32.32)')
        booleanParam(name: 'AGENT_C', defaultValue: false, description: 'âš ï¸  Agent C - Hazard Detection (10.255.32.128)')
        booleanParam(name: 'STREAMING', defaultValue: false, description: 'ðŸ“¹ Streaming Middleware - Nginx RTMP (10.255.32.35)')
        booleanParam(name: 'KAFKA', defaultValue: false, description: 'ðŸ“¨ Kafka Broker (10.255.32.143)')
        booleanParam(name: 'DATA_MODULE', defaultValue: false, description: 'ðŸ’¾ Data Module + Databases (10.255.32.82)')
        booleanParam(name: 'DECISION_ENGINE', defaultValue: false, description: 'ðŸ§  Decision Engine (10.255.32.104)')
        booleanParam(name: 'API_GATEWAY', defaultValue: false, description: 'ðŸŒ API Gateway (10.255.32.100)')
        booleanParam(name: 'UI', defaultValue: false, description: 'ðŸ–¥ï¸  Frontend UI (10.255.32.108)')
        
        // ================================================================
        // OPÃ‡Ã•ES ADICIONAIS
        // ================================================================
        string(
            name: 'BRANCH',
            defaultValue: 'main',
            description: 'Git branch (para deploy)'
        )
        
        string(
            name: 'LOG_LINES',
            defaultValue: '100',
            description: 'NÃºmero de linhas de log a mostrar (para aÃ§Ã£o logs)'
        )
    }
    
    environment {
        // VM IPs - Mapeamento serviÃ§o â†’ VM
        AGENTA_IP = '10.255.32.134'
        AGENTB_IP = '10.255.32.32'
        AGENTC_IP = '10.255.32.128'
        STREAMING_IP = '10.255.32.80'
        KAFKA_IP = '10.255.32.143'
        DATA_MODULE_IP = '10.255.32.82'
        DECISION_ENGINE_IP = '10.255.32.104'
        API_GATEWAY_IP = '10.255.32.100'
        UI_IP = '10.255.32.108'
        
        // Repositories
        BACKEND_REPO = 'https://github.com/PEI-HAZARDS/IntelligentLogistics.git'
        APP_REPO = 'https://github.com/PEI-HAZARDS/IntelligentLogistics_APP.git'
    }
    
    stages {
        stage('ðŸ“‹ Validar SeleÃ§Ã£o') {
            steps {
                script {
                    // Expandir ALL_SERVICES
                    if (params.ALL_SERVICES) {
                        env.SEL_AGENT_A = 'true'
                        env.SEL_AGENT_B = 'true'
                        env.SEL_AGENT_C = 'true'
                        env.SEL_STREAMING = 'true'
                        env.SEL_KAFKA = 'true'
                        env.SEL_DATA_MODULE = 'true'
                        env.SEL_DECISION_ENGINE = 'true'
                        env.SEL_API_GATEWAY = 'true'
                        env.SEL_UI = 'true'
                    } else {
                        env.SEL_AGENT_A = params.AGENT_A.toString()
                        env.SEL_AGENT_B = params.AGENT_B.toString()
                        env.SEL_AGENT_C = params.AGENT_C.toString()
                        env.SEL_STREAMING = params.STREAMING.toString()
                        env.SEL_KAFKA = params.KAFKA.toString()
                        env.SEL_DATA_MODULE = params.DATA_MODULE.toString()
                        env.SEL_DECISION_ENGINE = params.DECISION_ENGINE.toString()
                        env.SEL_API_GATEWAY = params.API_GATEWAY.toString()
                        env.SEL_UI = params.UI.toString()
                    }
                    
                    // Verificar se algo foi selecionado
                    def anySelected = [
                        env.SEL_AGENT_A, env.SEL_AGENT_B, env.SEL_AGENT_C,
                        env.SEL_STREAMING, env.SEL_KAFKA, env.SEL_DATA_MODULE,
                        env.SEL_DECISION_ENGINE, env.SEL_API_GATEWAY, env.SEL_UI
                    ].any { it == 'true' }
                    
                    if (!anySelected) {
                        error "âŒ Nenhum serviÃ§o selecionado! Seleciona pelo menos um serviÃ§o."
                    }
                    
                    echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ðŸŽ›ï¸  PAINEL DE CONTROLO                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  AÃ§Ã£o: ${params.ACTION.toUpperCase().padRight(52)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ServiÃ§os selecionados:                                       â•‘
â•‘    ${env.SEL_AGENT_A == 'true' ? 'âœ…' : 'â¬œ'} Agent A           ${env.SEL_STREAMING == 'true' ? 'âœ…' : 'â¬œ'} Streaming                   â•‘
â•‘    ${env.SEL_AGENT_B == 'true' ? 'âœ…' : 'â¬œ'} Agent B           ${env.SEL_KAFKA == 'true' ? 'âœ…' : 'â¬œ'} Kafka                        â•‘
â•‘    ${env.SEL_AGENT_C == 'true' ? 'âœ…' : 'â¬œ'} Agent C           ${env.SEL_DATA_MODULE == 'true' ? 'âœ…' : 'â¬œ'} Data Module                  â•‘
â•‘    ${env.SEL_DECISION_ENGINE == 'true' ? 'âœ…' : 'â¬œ'} Decision Engine  ${env.SEL_API_GATEWAY == 'true' ? 'âœ…' : 'â¬œ'} API Gateway                  â•‘
â•‘    ${env.SEL_UI == 'true' ? 'âœ…' : 'â¬œ'} UI                                                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                }
            }
        }
        
        stage('ðŸ”Œ Verificar Conectividade') {
            when { expression { return params.ACTION != 'status' } }
            steps {
                script {
                    echo "ðŸ” Verificando conectividade Ã s VMs..."
                    
                    def vmChecks = [:]
                    
                    if (env.SEL_AGENT_A == 'true') vmChecks['Agent A'] = AGENTA_IP
                    if (env.SEL_AGENT_B == 'true') vmChecks['Agent B'] = AGENTB_IP
                    if (env.SEL_AGENT_C == 'true') vmChecks['Agent C'] = AGENTC_IP
                    if (env.SEL_STREAMING == 'true') vmChecks['Streaming'] = STREAMING_IP
                    if (env.SEL_KAFKA == 'true') vmChecks['Kafka'] = KAFKA_IP
                    if (env.SEL_DATA_MODULE == 'true') vmChecks['Data Module'] = DATA_MODULE_IP
                    if (env.SEL_DECISION_ENGINE == 'true') vmChecks['Decision Engine'] = DECISION_ENGINE_IP
                    if (env.SEL_API_GATEWAY == 'true') vmChecks['API Gateway'] = API_GATEWAY_IP
                    if (env.SEL_UI == 'true') vmChecks['UI'] = UI_IP
                    
                    vmChecks.each { name, ip ->
                        def result = sh(
                            script: "timeout 5 bash -c 'cat < /dev/null > /dev/tcp/${ip}/22' 2>/dev/null",
                            returnStatus: true
                        )
                        if (result != 0) {
                            error "âŒ NÃ£o foi possÃ­vel conectar a ${name} (${ip})"
                        }
                        echo "âœ… ${name} (${ip}) - AcessÃ­vel"
                    }
                }
            }
        }
        
        stage('ðŸ“¥ Checkout') {
            when { expression { return params.ACTION == 'deploy' } }
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: BACKEND_REPO]]
                ])
            }
        }
        
        // ================================================================
        // AGENT A
        // ================================================================
        stage('ðŸšš Agent A') {
            when { expression { return env.SEL_AGENT_A == 'true' } }
            steps {
                script {
                    executeAction('agentA', AGENTA_IP, 'src/agentA_microservice', 'agentA')
                }
            }
        }
        
        // ================================================================
        // AGENT B
        // ================================================================
        stage('ðŸ”¢ Agent B') {
            when { expression { return env.SEL_AGENT_B == 'true' } }
            steps {
                script {
                    executeAction('agentB', AGENTB_IP, 'src/agentB_microservice', 'agentB')
                }
            }
        }
        
        // ================================================================
        // AGENT C
        // ================================================================
        stage('âš ï¸ Agent C') {
            when { expression { return env.SEL_AGENT_C == 'true' } }
            steps {
                script {
                    executeAction('agentC', AGENTC_IP, 'src/agentC_microservice', 'agentC')
                }
            }
        }
        
        // ================================================================
        // STREAMING MIDDLEWARE
        // ================================================================
        stage('ðŸ“¹ Streaming') {
            when { expression { return env.SEL_STREAMING == 'true' } }
            steps {
                script {
                    executeAction('nginx-rtmp', STREAMING_IP, 'src/streaming_middleware', 'nginx-rtmp', '1935:1935,8080:8080')
                }
            }
        }
        
        // ================================================================
        // KAFKA
        // ================================================================
        stage('ðŸ“¨ Kafka') {
            when { expression { return env.SEL_KAFKA == 'true' } }
            steps {
                script {
                    if (params.ACTION == 'deploy') {
                        deployKafka(KAFKA_IP)
                    } else {
                        // Para Kafka, verificar mÃºltiplos containers
                        executeActionMulti(['zookeeper', 'kafka', 'kafka-ui'], KAFKA_IP)
                    }
                }
            }
        }
        
        // ================================================================
        // DATA MODULE
        // ================================================================
        stage('ðŸ’¾ Data Module') {
            when { expression { return env.SEL_DATA_MODULE == 'true' } }
            steps {
                script {
                    if (params.ACTION == 'deploy') {
                        deployDataModule(DATA_MODULE_IP)
                    } else {
                        executeActionMulti(['dm_postgres', 'dm_mongo', 'dm_redis', 'minio', 'dm_data_module'], DATA_MODULE_IP)
                    }
                }
            }
        }
        
        // ================================================================
        // DECISION ENGINE
        // ================================================================
        stage('ðŸ§  Decision Engine') {
            when { expression { return env.SEL_DECISION_ENGINE == 'true' } }
            steps {
                script {
                    executeAction('decision-engine', DECISION_ENGINE_IP, 'src/decision_engine_microservice', 'decision-engine')
                }
            }
        }
        
        // ================================================================
        // API GATEWAY
        // ================================================================
        stage('ðŸŒ API Gateway') {
            when { expression { return env.SEL_API_GATEWAY == 'true' } }
            steps {
                script {
                    executeAction('api_gateway', API_GATEWAY_IP, 'src/api_gateway', 'api_gateway', '8000:8000')
                }
            }
        }
        
        // ================================================================
        // UI
        // ================================================================
        stage('ðŸ–¥ï¸ UI') {
            when { expression { return env.SEL_UI == 'true' } }
            steps {
                script {
                    if (params.ACTION == 'deploy') {
                        deployUI(UI_IP)
                    } else {
                        executeAction('ui_il', UI_IP, null, 'ui_il')
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              âœ… OPERAÃ‡ÃƒO CONCLUÃDA COM SUCESSO                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        }
        failure {
            echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âŒ OPERAÃ‡ÃƒO FALHOU                         â•‘
â•‘                  Ver logs acima para detalhes                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        }
        always {
            cleanWs()
        }
    }
}

// ============================================================================
// FUNÃ‡Ã•ES AUXILIARES
// ============================================================================

def executeAction(String containerName, String vmIp, String buildPath, String imageName, String ports = '') {
    /**
     * Executa a aÃ§Ã£o selecionada num container especÃ­fico
     */
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        def sshCmd = "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${vmIp}"
        
        switch(params.ACTION) {
            case 'status':
                echo "ðŸ“Š Estado de ${containerName} em ${vmIp}:"
                sh """
                    mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                    ${sshCmd} 'docker ps -a --filter name=${containerName} --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\\t{{.Image}}"'
                """
                break
                
            case 'logs':
                echo "ðŸ“œ Logs de ${containerName} em ${vmIp}:"
                sh """
                    mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                    ${sshCmd} 'docker logs --tail ${params.LOG_LINES} ${containerName} 2>&1' || echo "Container nÃ£o encontrado ou sem logs"
                """
                break
                
            case 'restart':
                echo "ðŸ”„ Reiniciando ${containerName} em ${vmIp}..."
                sh """
                    mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                    ${sshCmd} 'docker restart ${containerName}'
                """
                echo "âœ… ${containerName} reiniciado"
                break
                
            case 'stop':
                echo "â¹ï¸ Parando ${containerName} em ${vmIp}..."
                sh """
                    mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                    ${sshCmd} 'docker stop ${containerName}'
                """
                echo "âœ… ${containerName} parado"
                break
                
            case 'deploy':
                echo "ðŸ“¦ Deploy de ${containerName} para ${vmIp}..."
                
                sh """
                    mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                    
                    cat > ~/.ssh/config << EOF
Host ${containerName}-vm
    HostName ${vmIp}
    User \$SSH_USER
    IdentityFile ~/.ssh/deploy_key
    StrictHostKeyChecking no
    UserKnownHostsFile=/dev/null
EOF
                    
                    docker context create ${containerName}_ctx --docker "host=ssh://${containerName}-vm" 2>/dev/null || true
                    docker context use ${containerName}_ctx
                    
                    cd ${buildPath}
                    docker compose build 2>/dev/null || docker build -t ${imageName}:latest .
                    
                    docker stop ${containerName} 2>/dev/null || true
                    docker rm ${containerName} 2>/dev/null || true
                    
                    docker compose up -d 2>/dev/null || docker run -d \\
                        --name ${containerName} \\
                        --restart unless-stopped \\
                        ${ports ? ports.split(',').collect { "-p ${it}" }.join(' ') : ''} \\
                        ${imageName}:latest
                    
                    docker context use default
                """
                echo "âœ… ${containerName} deployed"
                break
        }
    }
}

def executeActionMulti(List<String> containers, String vmIp) {
    /**
     * Executa a aÃ§Ã£o em mÃºltiplos containers (ex: Kafka tem 3 containers)
     */
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        def sshCmd = "ssh -i \$SSH_KEY -o StrictHostKeyChecking=no \$SSH_USER@${vmIp}"
        
        switch(params.ACTION) {
            case 'status':
                echo "ðŸ“Š Estado dos containers em ${vmIp}:"
                sh """
                    mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                    ${sshCmd} 'docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"'
                """
                break
                
            case 'logs':
                containers.each { container ->
                    echo "ðŸ“œ Logs de ${container}:"
                    sh """
                        mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                        ${sshCmd} 'docker logs --tail ${params.LOG_LINES} ${container} 2>&1' || echo "Container nÃ£o encontrado"
                    """
                }
                break
                
            case 'restart':
                echo "ðŸ”„ Reiniciando containers em ${vmIp}..."
                containers.each { container ->
                    sh """
                        mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                        ${sshCmd} 'docker restart ${container} 2>/dev/null' || echo "${container} nÃ£o encontrado"
                    """
                }
                echo "âœ… Containers reiniciados"
                break
                
            case 'stop':
                echo "â¹ï¸ Parando containers em ${vmIp}..."
                containers.reverse().each { container ->
                    sh """
                        mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
                        ${sshCmd} 'docker stop ${container} 2>/dev/null' || echo "${container} nÃ£o encontrado"
                    """
                }
                echo "âœ… Containers parados"
                break
        }
    }
}

def deployKafka(String vmIp) {
    echo "ðŸ“¦ Deploying Kafka stack to ${vmIp}..."
    
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        sh """
            mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
            
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \$SSH_USER@${vmIp} << 'ENDSSH'
                docker network create kafka-net 2>/dev/null || true
                
                docker stop kafka kafka-ui zookeeper 2>/dev/null || true
                docker rm kafka kafka-ui zookeeper 2>/dev/null || true
                
                docker run -d --name zookeeper --network kafka-net --restart unless-stopped \\
                    -e ZOOKEEPER_CLIENT_PORT=2181 \\
                    confluentinc/cp-zookeeper:latest
                
                sleep 10
                
                docker run -d --name kafka --network kafka-net --restart unless-stopped \\
                    -p 9092:9092 \\
                    -e KAFKA_BROKER_ID=1 \\
                    -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\
                    -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://${vmIp}:9092 \\
                    -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \\
                    confluentinc/cp-kafka:latest
                
                sleep 10
                
                docker run -d --name kafka-ui --network kafka-net --restart unless-stopped \\
                    -p 8080:8080 \\
                    -e KAFKA_CLUSTERS_0_NAME=intelligent-logistics \\
                    -e KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9092 \\
                    provectuslabs/kafka-ui:latest
                
                echo "âœ… Kafka stack deployed"
ENDSSH
        """
    }
}

def deployDataModule(String vmIp) {
    echo "ðŸ“¦ Deploying Data Module stack to ${vmIp}..."
    
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER'),
        usernamePassword(credentialsId: 'minio-credentials', usernameVariable: 'MINIO_USER', passwordVariable: 'MINIO_PASS')
    ]) {
        sh """
            mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
            
            # Copiar docker-compose e .env para a VM
            scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \\
                src/Data_Module/docker-compose.yml \\
                \$SSH_USER@${vmIp}:~/data-module/
            
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \$SSH_USER@${vmIp} << ENDSSH
                cd ~/data-module
                docker compose down 2>/dev/null || true
                docker compose pull
                docker compose up -d
                echo "âœ… Data Module stack deployed"
ENDSSH
        """
        
        // Deploy da aplicaÃ§Ã£o Data Module
        sh """
            docker context create data_module_ctx --docker "host=ssh://\$SSH_USER@${vmIp}" 2>/dev/null || true
            docker context use data_module_ctx
            
            cd src/Data_Module
            docker compose build
            docker compose up -d
            
            docker context use default
        """
    }
}

def deployUI(String vmIp) {
    echo "ðŸ“¦ Deploying UI to ${vmIp}..."
    
    withCredentials([
        sshUserPrivateKey(credentialsId: 'ssh-vm-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')
    ]) {
        // Checkout do repo da APP
        dir('app') {
            checkout([
                $class: 'GitSCM',
                branches: [[name: "*/${params.BRANCH}"]],
                userRemoteConfigs: [[url: APP_REPO]]
            ])
        }
        
        sh """
            mkdir -p ~/.ssh && cp \$SSH_KEY ~/.ssh/deploy_key && chmod 600 ~/.ssh/deploy_key
            
            docker context create ui_ctx --docker "host=ssh://\$SSH_USER@${vmIp}" 2>/dev/null || true
            docker context use ui_ctx
            
            cd app
            docker build -t ui_il:latest .
            docker stop ui_il 2>/dev/null || true
            docker rm ui_il 2>/dev/null || true
            docker run -d --name ui_il --restart unless-stopped -p 3000:3000 ui_il:latest
            
            echo "âœ… UI deployed"
            docker context use default
        """
    }
}
